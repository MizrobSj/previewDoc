|--------|
| ОСНОВА |
|--------|

Пример написани заголовков и коментариев для коммитов


Заголовок должен состоять максимум из 50 characters и в конце не должна ставиться точка

Комментарии могут быть большими но 70 characters в ширину чтобы было удобно читать в терминале.

Комиты которые недоступны по одной из ссылок называются Недостижимые и гит удаляет их

gc.reflogExpire = "90 days ago" - 90 дней
gc.reflogExpireUnreachable = "30 days ago" - 30 дней
=========================================================================================
--system - конфигурация на уровне системы (path C:\Program Files\Git\etc\gitconfig)

=========================================================================================

--global - конфигурация на уровне пользователя (.gitconfig - path C:\Users\<Username>\.gitconfig)
 
git config --global user.name "Mizrob" - ставит имя пользователя для гит

git config --unset user.name - чтобы убрать имя пользователя 

git config --list - вывод всех параметров

git config --list --global - вывод глобальных параметров

git config --global core.editor 'Path to Editor' - выбор редактора для гит

git config alias.nameofthealias 'command for change'

===========================================================================================
--local - конфигурация на уровне проекта

git init - создаёт внутри проекта .git

git status - показывает статус файлов

git add <filename> - добавляет файл для изменений

git add -p <filename> - добавляет тот код который вы хотите комитнуть

git show <idofcommit>- показывает файлы которые были коммитнуты

git reset HEAD <filename> - откатывает файл в untracked стадию

git commit -m  'some message '- позволяет добовлять комментарии в самом терминале

git commit -a - команда Git для коммита всех измененных файлов без предварительного добавления (staging).

git commit <path> - команда Git для коммита конкретного файла или директории, указанного в <path>

git rm <path> - удалить файл из индекса и рабочего каталога.

git rm -r - рекурсивное удаление директории из индекса и рабочего каталога.

git rm -r --cached - рекурсивное удаление директории из индекса, но оставить в рабочем каталоге.

git rm -f - принудительное удаление файла из индекса и рабочего каталога.

git mv <filename> <filename> - переместить или переименовать файл.

===========================================================================================
-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
===========================================================================================
commit_id - идентификатор коммита

|-------|
| ВЕТКИ |
|-------|


git commit -am 'message' - коммит всех изменений, включая добавленные и удаленные файлы, c комментарием

git branch <branchname> - создать новую ветку с именем <branchname>.

git branch -v - показать список веток с кратким описанием коммитов.

git checkout <branchname> - переходит в созданную ветку

git checkout -f <branchname> - переключиться на ветку <branchname>, отменяя все изменения в рабочем каталоге.

git stash - временно сохранить изменения.

git stash pop - восстановить изменения из временного хранилища.

git branch -f master <commit_id> - перенести ветку master на указанный коммит <commit_id>.

git checkout -B master <commit_id> - создать и переключиться на ветку master, указав коммит <commit_id>.

git cherry-pick - применить выбранный коммит к текущей ветке.

git checkout <paths> - отменить изменения в указанных файлах.

git checkout HEAD <paths> - восстановить указанные файлы до состояния HEAD.

git log - показать историю коммитов.

git log --oneline - показать историю коммитов в одной строке.

git show HEAD~ - показать изменения в последнем коммите.

git merge - объединить изменения из другой ветки в текущую.

git branch -f master ORIG_HEAD - восстановить ветку master после слияния.

git branch -d <branchname> - удалить ветку (безопасное удаление).

git branch -D <branchname> - удалить ветку (принудительное удаление).

git branch <branchname> <commit_id> - создать ветку с указанным именем, начиная с указанного коммита. Тоесть восстонавливает удаллёную ветку

git branch <branchname> HEAD@{number} - создать ветку с указанным именем, начиная с коммита в истории по его номеру.

cat .git/logs/HEAD - просмотреть логи коммитов.

git reflog - показать журнал изменений HEAD.

git reflog show - показать журнал изменений HEAD с комментариями.

git reflog --date=iso - показать журнал изменений HEAD с датами в формате ISO.


git clean -dxf - удалить все неотслеживаемые файлы и директории в рабочем каталоге.

============================================================================================
-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
===========================================================================================
commit_id - идентификатор коммита

|-------|
| RESET |
|-------|
git help reset - таблица с отличиями reset

git reset @~ - один коммит назад

git reset --soft @~ - нетрогая рабочую директорию и индекс перезагружает на один коммит, используется для переделования неудачных коммитов

git reset @~ - отменить последний коммит, оставив изменения в рабочем каталоге.

git reset HEAD - отменить индексацию (unstage) всех файлов.

git reset --hard - отменить последние коммиты и сбросить рабочий каталог до HEAD.

git reset --soft @~ - отменить последний коммит, оставив изменения в индексе.

git commit -c ORIG_HEAD - отредактировать последний коммит с использованием старого 
сообщения коммита.

git commit -C ORIG_HEAD - создать новый коммит с использованием старого сообщения коммита.

git commit -C ORIG_HEAD --reset-author - создать новый коммит с использованием старого 
сообщения и сброса автора.

git commit --amend - изменить последний коммит, включив в него новые изменения.

git commit --amend --no-edit - изменить последний коммит, не изменяя его сообщение.

git branch -v - показать список веток с кратким описанием коммитов.


============================================================================================
-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
===========================================================================================
commit_id - идентификатор коммита

|----------|
| ПРОСМОТР |
|----------|
git diff <commit_id> <commit_id> or git diff <branchname> <branchname> - сравнение двух коммитов

git diff <branchname>...<branchname> - показать разницу между двумя ветками.

git diff HEAD - показать разницу между рабочим каталогом и последним коммитом.

git diff --cached - показать разницу между индексом и последним коммитом.

git commit -v - показать изменения в комментарии к коммиту перед его созданием.

git config --global commit.verbose true - включить подробные изменения в комментарии к 
коммиту (глобально).

git diff <filename> - показать разницу для определенного файла.

git log --pretty - показать коммиты с форматированием по умолчанию.

git log --pretty=format:' %h %cd | %s%d [%an]' - настроить формат вывода для коммитов в 
журнале.

git log -p - показать изменения в каждом коммите.

git log <branchname> <branchname> --graph - показать историю коммитов с графическим представлением ветвлений.

git log --all --graph - показать граф истории всех веток.

git log <branchname> ...<branchname> --boundary --graph - показать границы между ветками в 
графе истории.

git log -p --follow <filename> - показать изменения файла в истории, включая его 
переименования.

git log --grep <name> <branchname> - показать коммиты, соответствующие заданному 
регулярному выражению.

git log -G<name> - показать коммиты, где было изменение, соответствующее заданному регулярному выражению.

git log -L - показать изменения в определенном диапазоне строк для файла.

git log --author=<name> - показать коммиты, сделанные определенным автором.

git blame <filename> - показать, кто последний изменял каждую строку в файле.


============================================================================================
-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
===========================================================================================
commit_id - идентификатор коммита

|----------|
|   MERGE  |
|----------|

git merge-base <branchname> <branchname> - найти общего предка для двух веток.


git checkout --ours <filename> - использовать текущую версию файла при разрешении конфликта слияния.


git checkout --theirs <filename> - использовать версию файла из другой ветки при разрешении конфликта слияния.


git checkout --merge <filename> - использовать объединенную версию файла при разрешении конфликта слияния.


git merge --abort - отменить процесс слияния.


git checkout --conflict=diff3 --merge <filename> - использовать diff3-стиль при разрешении конфликта слияния.


git show :1:<filename>, git show :2:<filename>, git show :3:<filename> - показать содержимое файла в индексах 1, 2 и 3 соответственно после конфликта слияния.


git merge --continue - продолжить процесс слияния после разрешения конфликта.


git diff HEAD^ - показать изменения в последнем коммите перед HEAD.


git merge <branchname> --log - выполнить слияние с отображением лога изменений.


git merge --log - выполнить слияние с отображением лога изменений (без указания ветки).


git merge <branchname> --no-commit - выполнить слияние без создания коммита.


git merge --no-ff --no-edit <branchname> - выполнить слияние, создавая коммит с фиксированным сообщением.


git merge --squash <branchname> - выполнить слияние, объединяя все изменения в один коммит.



============================================================================================
-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
===========================================================================================
commit_id - идентификатор коммита

|----------|
|   COPPY  |
|----------|

git cherry-pick <commit_id> - применить копирование с указанным идентификатором.


git cherry-pick -x - применить копирование с сохранением оригинальных авторских данных.


git cherry-pick <branchname>..<branchname> - применить изменения из диапазона коммитов между двумя ветками.


git cherry-pick --abort - отменить процесс cherry-pick.


git cherry-pick --continue - продолжить процесс cherry-pick после разрешения конфликтов.


git cherry-pick --quit - завершить cherry-pick без коммита.


git cherry-pick -n <commit_id> - начать cherry-pick, но не создавать коммит автоматически.


============================================================================================
-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
===========================================================================================
commit_id - идентификатор коммита

|----------|
|  REBASE  |
|----------|

git rebase <branchname> - переместить текущую ветку на вершину указанной ветки.

git rebase --quit - завершить процесс rebase и оставить все как есть.

git rebase --skip - пропустить текущий коммит в процессе rebase.

git rebase --continue - продолжить процесс rebase после разрешения конфликтов.

git rebase -x 'make test' <branchname> - выполнить команду после каждого коммита в процессе rebase.

git rebase --onto <branchname> <branchname> - перебазировать текущую ветку на указанную ветку.

git rebase --onto <branchname> @~2 - перебазировать последние два коммита на указанную ветку.

git rebase --rebase-merges <branchname> - перебазировать, сохраняя слияния в истории.

git rebase -i - интерактивное перебазирование для редактирования коммитов.

git rebase -i --autosquash - интерактивное перебазирование с автоматическим применением правил autosquash для коррекции коммитов.

============================================================================================



PLAN OF GOOD COMMIT 

NOTE: Нужно использовать двухступенчетую систему сохранений и никогда не комитать весь проект целиком 
а по отдельным файлам чтобы команда не запуталась 

Index - файлы которые отслеживаются

    WORKING DIRECTORY				   INDEX				REPOSITORY

|-----------------------|		|-----------------------|		|-----------------------|
|			|		|			|		|			|
|			|		|			|		|			|
|			|		|			|		|			|
|			|		|			|		|			|
|			|   add-->	|			|  commit-->	|			|
|			|		|			|		|			|
|			|		|			|		|			|
|-----------------------|		|-----------------------|		|-----------------------|


Также используя команду git add -p <filename> вы можете комитать не весь код в файле а те которые вы выполнили